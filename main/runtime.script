
local swtest = require("main.swampy-warbattlesmp")
local json 	 = require("swampy.utils.json")
local chance = require("lua.chance")
local utils  = require("lua.utils")

local bser 	 = require("lua.binser")
local rlua 	 = require("render.render")

-- Dodgy fixed point to start with
local START_POS 	= vmath.vector3(500, 500, 1)

local COLOR_WHITE 	= vmath.vector4(1, 1, 1, 1)

-- ---------------------------------------------------------------------------

local function colorgen()

	local deg = math.rad(120) -- used for stepping rgb
	local rdeg = math.floor(math.random(1, 360) / 16) * 16
	local d1 = math.rad(rdeg)

	local col = vmath.vector4()
	col.x = (math.sin(d1) + 1.0) * 0.5
	col.y = (math.sin(d1 + deg) + 1.0) * 0.5
	col.z = (math.sin(d1 + deg + deg) + 1.0) * 0.5
	col.w = 1.0
	return col
end 
	
-- ---------------------------------------------------------------------------

local function logtext(self, str)

	pprint(str)
	-- msg.post("/gui#log", "logtext", { text = str } )
end 

-- ---------------------------------------------------------------------------

local function startgame(self, data)

	-- Apply a fake name to start
	logtext(self, data["status"])
	msg.post("/gui-lobby", "gamestart")
	--pprint(self.game)
	msg.post("/gui-players", "gamestart", { people = self.game.people, myname = self.player_name })
	msg.post("/gui-players", "gamename", { gamename = self.game.gamename })
end

-- ---------------------------------------------------------------------------

local function setname(self, name, callback)

	self.player_color	= colorgen()
	self.player_name 	= name
	self.player_uid 	= self.user_id
	swtest.updateaccount( self, function(data) 
		callback(data)
	end)
end

-- ---------------------------------------------------------------------------

local function websocket_callback(self, conn, data)
	if data.event == websocket.EVENT_DISCONNECTED then
		pprint("Disconnected: " .. tostring(conn))
		self.ws_connect = nil
	elseif data.event == websocket.EVENT_CONNECTED then
		pprint("Connected: " .. tostring(conn))
	elseif data.event == websocket.EVENT_ERROR then
		pprint("Error: '" .. data.message .. "'")
	elseif data.event == websocket.EVENT_MESSAGE then
		pprint("Receiving: '" .. tostring(data.message) .. "'")
	end
end

-- ---------------------------------------------------------------------------

local function joingame(self) 

	-- First connect 
	swtest.connect(self, function(data) 
		logtext(self, "Connection: "..tostring(data))

		setname(self, chance:name(), function(data) 
			-- find the game name 
			swtest.findgame( self, self.gamename, function(data) 
				logtext(self, data["status"])
				-- Game not found, then create one and join!
				if(data["status"] ~= "OK") then 

					swtest.creategame( self, self.gamename, function(data) 
						if(data.status and data.status == "OK") then 
							self.game = json.decode(data.result)
							swtest.websocket_open(self, websocket_callback)
						end
						startgame(self, data)
					end)
				-- Found the game!
				else
					swtest.joingame( self, self.gamename, function(data) 
						if(data.status and data.status == "OK") then 
							self.game = json.decode(data.result)
						end
						startgame(self, data)
					end)
				end 
			end) 
		end)
	end)
end 

-- ---------------------------------------------------------------------------
-- Players have either left or joined the game. 
--   Find out who, and then add/remove other player objects
--   Also determines if we have all the players that are in the game 
--   during startup and adds them 
local function playerschanged(self) 

	-- print("PEOPLE:", utils.tcount(self.game.people))
	for k,v in ipairs(self.game.people) do 
		-- Missing player - add it! - disable input!!
		-- dont add self 
		if(self.player_uid ~= v.uid) then 
			if(self.otherplayers[v.uid] == nil) then 

				-- print("creating other player: ", v.uid, v.username)
				local newplayer = factory.create("/players#playerfactory", START_POS, nil, {})
				msg.post(newplayer, "player_details", { name = v.username, color = COLOR_WHITE, other=true})
				self.otherplayers[v.uid] = newplayer
			end 
		end
	end 
end
-- ---------------------------------------------------------------------------

function updatestates(self)

	if(self.game.state == nil) then return end 
	local state_count = utils.tcount(self.game.state)
	-- pprint("[STATE COUNT]", state_count)
	for i = 1, state_count do 
		local v = table.remove(self.game.state, 1)
		if(v and v.uid) then 
			local pid = self.otherplayers[v.uid]
			if(pid) then
				-- local pos = vmath.vector3(v.x, v.y, 1)
				--go.animate(pid, "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 0.2)
				--go.set_position(pos, pid)
				msg.post(pid, "player_move", v)
			end 
		end 
	end
	-- Consume whole state list
	self.game.state = nil
end 

-- ---------------------------------------------------------------------------

function init(self)
	self.gamerunning 	= false
	self.otherplayers 	= {}
	self.frame 			= 0
	self.sendbuffer 	= {}

	msg.post(".", "acquire_input_focus")
	chance:seed(os.time())

	swtest.setup(self, "WarBattlesMP", "player1")
	swtest.login(self, function(data) 
		logtext(self, "Login OK.")
	end)

	msg.post ("@render:", "use_player_pos", { player_pos = vmath.vector3() })
end

-- ---------------------------------------------------------------------------

function final(self)
	if(self.game) then swtest.websocket_open(self) end
end

-- ---------------------------------------------------------------------------

function update(self, dt)

	-- Polling is used to sync game state from server
	if(self.frame % 180 == 0) then 
		if(self.game and self.game.people) then
			local plist = ""
			for k,v in ipairs(self.game.people) do 
				plist = plist..v.username.."\n"
			end 
			msg.post("/gui#ui", "update_players", {players = plist})
		end 
	end

	-- if(self.frame % 10 == 0) then 
	-- 	if(self.game) then 
	-- 		local data = table.remove( self.sendbuffer, 1 )
	-- 		swtest.sendplayerdata( self, data)
	-- 	end 
	-- end
	-- 
	if(self.frame % 10 == 0) then 
		if(self.game) then 
			swtest.reqround( self, function(data)
				if(data.status == "OK") then 
--					print("[DATALEN]", string.len(data.result))
					self.game.state = bser.deserialize(data.result)[1]
					updatestates(self) 
				end 
			end)
		end
	end

	if(self.frame % 30 == 0) then 
		
		if(self.game) then 
			swtest.reqpeople( self, function(data)
				if(data.status == "OK") then 
					if(string.len(data.result) > 2) then 
						self.game.people = bser.deserialize(data.result)[1]
						local ocount = utils.tcount(self.otherplayers)
						if(ocount + 1 ~= #self.game.people) then 
							playerschanged(self)
						end
					end
				end
			end)
		end
	end
	self.frame = self.frame + 1
end

-- ---------------------------------------------------------------------------

local function cleanupgame(self)

	print("[CLEANUP GAME]")
	if(self.thisplayer) then 
		go.delete(self.thisplayer)
		self.thisplayer = nil 
	end
	
	for k,v in pairs(self.otherplayers) do 
		go.delete(v)
	end 
	self.otherplayers = {}
end

-- ---------------------------------------------------------------------------

local function togglegui(self)
	self.gamerunning = not self.gamerunning
	if(self.gamerunning) then 
		msg.post("/gui-bg", "disable")	
		msg.post("/gui-lobby", "disable")	
		msg.post("/gui-players", "disable")
		msg.post ("@render:", "use_player_pos", { player_pos = vmath.vector3() })
	else
		msg.post("/gui-bg", "enable")	
		msg.post("/gui-lobby", "enable")	
	end

	if(self.gamerunning == false) then 
		cleanupgame(self)
	end 
end

-- ---------------------------------------------------------------------------

function on_message(self, message_id, message, sender)

	if( message_id== hash("togglegui") ) then 
		togglegui(self)
	end
	-- Joining can mean either joining a current game or creating and joining a new one
	if( message_id== hash("joingame") ) then 
		self.otherplayers 	= {}
		self.gamename = message.gamename
		msg.post("/gui#ui", "update_gamename", {name = self.gamename})
		if(self.gamename and string.len(self.gamename)) then 
			joingame(self)
		end 
	end
	if( message_id== hash("setname") ) then 
		if(message.name and string.len(message.name)) then 
			setname(self, message.name, function(data) 
				swtest.updategame( self, function(gamedata)
					self.game = json.decode(gamedata)
					-- pprint(gamedata)
					msg.post("/gui-players", "gamestart", { people = self.game.people })
				end)
			end)
		end 
	end
	if(message_id == hash("mainmenu") ) then 
		msg.post("/gui-bg", "enable")	
		msg.post("/gui-lobby", "enable")	
		msg.post("/gui-players", "disable")
		swtest.leavegame( self, self.gamename, function(data) 
			self.game = nil
		end)
	end

	if(message_id == hash("begingame") ) then 

		-- TODO: put this in a func
		self.thisplayer = factory.create("/players#playerfactory", START_POS, nil, {})
		msg.post(self.thisplayer, "player_details", {name = self.player_name, color = self.player_color})
		self.gamerunning = true
	end

	-- Send server player move
	--    Server collects these, then sends out to other players in state 
	--    output. 
	if(message_id == hash("move_player") ) then 

		local state 	= message.state 
		local w,h 		= rlua.get_win()
		target_player_pos = vmath.vector3(-state.x + w * 0.5, -state.y + h * 0.5, 0)
		msg.post ("@render:", "use_player_pos", { player_pos = target_player_pos })
		state.uid 		= self.user_id
		-- message.lt = 1, -- Can set lifetime of state
		swtest.sendplayerdata( self, bser.serialize(state))
		--table.insert(self.sendbuffer, bser.serialize(send_state))
	end 
end

-- ---------------------------------------------------------------------------

function on_input(self, action_id, action)

	if action_id == hash("escape") and action.pressed then
		pprint("Escaped pressed")
		togglegui(self)
	end
end

-- ---------------------------------------------------------------------------

function on_reload(self)
end

-- ---------------------------------------------------------------------------
